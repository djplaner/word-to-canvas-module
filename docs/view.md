# Structure of View

Aim is being to embed all information needed to control the representation of the model to the user. This includes user interaction (click events)

## Overview

The view represents the ?? states the app can be in
1. Initialised - the ".docx + Module" button has been added to the module
2. Choose Word - user needs to select the Word document to create the module from
3. Check HTML - check the HTML generated by converting the Word document
4. Check Module - check the Canvas module that will be created
5. Complete - display the results of creating the new module



## Design

### Data structures

- Different states are represented using an enum defined in the model source.
    - ```c2m_initialise```
    - ```c2m_chooseWord```
    - ```c2m_createHtml```
    - ```c2m_checkModule```
    - ```c2m_c2m_complete```
- Current state is stored in the model ```model.stage```

### Algorithms

Basic operation
1. Model 
    - created with stage set to ```c2m_initialise```
2. View 
    - passed the model
    - calls ```render``` - a big switch statement that then calls stage dependent method: ```renderInitialise renderChooseWord renderCheckHtml renderCheckModule renderComplete```

Event handling 

- event handlers are created by the different render functions, including any required click events
- each click event is a call to the views ```handleClick``` method accepting a stage enum
- ```handleClick``` - selects the specific event handler based on the stage enum

#### Example

When first run, the view will call ```renderInitialise```, which will - if there's already an add_module button on the page - 
1. add the ```c2m_word_2_module``` button with onclick ```handleClick(c2m_chooseWord)
2. remove the ```c2m_dialog``` div if it exists (i.e. user closed an existing conversion)


